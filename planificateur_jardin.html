<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planificateur de Jardin Avanc√©</title>
    <style>
        :root {
            --panel-width: 380px;
            --border-color: #ccc;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background-color: #f4f4f9;
        }

        /* --- NOUVELLE STRUCTURE : Panneau de contr√¥le fixe --- */
        #controls {
            width: var(--panel-width);
            min-width: var(--panel-width);
            padding: 15px;
            background-color: #ffffff;
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        /* --- NOUVELLE STRUCTURE : Conteneur de canvas scrollable --- */
        #canvas-container {
            flex-grow: 1;
            overflow: auto; /* Permet de scroller l'image si elle est trop grande */
            background-color: #e0e0e0;
            padding: 20px;
        }
        canvas {
            border: 2px dashed #999;
            background-color: #fff;
            display: block; /* Emp√™che les espaces parasites sous le canvas */
        }
        
        /* --- NOUVEAU STYLE : Menus d√©pliants --- */
        details {
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }
        details[open] {
            border-color: #4CAF50;
        }
        summary {
            font-weight: bold;
            padding: 10px;
            cursor: pointer;
            list-style: none; /* Cache la fl√®che par d√©faut */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        summary::-webkit-details-marker { display: none; } /* Cache la fl√®che sur Chrome/Safari */
        summary::after {
            content: '‚ñ∂';
            transition: transform 0.2s;
        }
        details[open] summary::after {
            transform: rotate(90deg);
        }
        .details-content {
            padding: 0 10px 10px 10px;
            border-top: 1px solid var(--border-color);
        }

        h1 { margin: 0 0 10px 0; }
        label { display: block; margin: 10px 0 5px 0; font-size: 0.9em; }
        input[type="text"], input[type="number"], input[type="file"] {
            width: calc(100% - 12px); padding: 5px; border: 1px solid var(--border-color); border-radius: 3px;
        }
        .input-group { display: flex; align-items: center; gap: 10px; }
        input[type="color"] { min-height: 28px; }
        
        button {
            background-color: #4CAF50; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 1em;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #45a049; }
        .button-group { display: flex; gap: 10px; }
        .button-secondary { background-color: #008CBA; } .button-secondary:hover { background-color: #007B9E; }
        .button-tertiary { background-color: #f44336; } .button-tertiary:hover { background-color: #da190b; }
        .button-orange { background-color: #f57c00; } .button-orange:hover { background-color: #e65100; }

        button.active-mode, button.grid-active {
            background-color: #ff9800; box-shadow: 0 0 5px rgba(0,0,0,0.5) inset;
        }

        #scale-info, #plant-list-container, #irrigation-info {
            font-size: 0.9em; background-color: #e9f5e9; padding: 10px; border-radius: 4px; margin-top: 10px; min-height: 20px;
        }
        #plant-types-list div {
            padding: 5px; border-radius: 3px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;
        }
        #plant-types-list div.selected { background-color: #cce5ff; font-weight: bold; }
        .plant-count {
            background-color: #4CAF50; color: white; border-radius: 10px; padding: 2px 8px; font-size: 0.8em; font-weight: bold;
        }

        canvas.mode-placing { cursor: crosshair; }
        canvas.mode-irrigation { cursor: copy; }
        canvas.scaling-mode { cursor: cell; }
        canvas.dragging-mode { cursor: grabbing; }
        canvas.mode-moving { cursor: grab; }
        canvas.mode-deleting { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' style='font-size: 24px;'><text y='24' x='0'>‚ùå</text></svg>") 16 16, auto; }
        canvas.grid-placement-mode { cursor: cell; }
        canvas.mode-paths { cursor: copy; }
        canvas.mode-mulching { cursor: crosshair; }

        /* --- Emoji Picker --- */
        #emoji-picker {
            position: absolute;
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            z-index: 100;
        }
        .emoji-picker-hidden {
            display: none !important;
        }
        #emoji-picker button {
            background-color: transparent;
            border: none;
            padding: 4px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        #emoji-picker button:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>

    <div id="controls">
        <h1>Planificateur de Jardin</h1>

        <details open>
            <summary>1. Plan & √âchelle</summary>
            <div class="details-content">
                <label for="imageLoader">Charger une image de fond :</label>
                <input type="file" id="imageLoader" name="imageLoader" accept="image/*">
                <label for="refDistance">Distance r√©elle (m) :</label>
                <input type="number" id="refDistance" value="10" min="0.1" step="0.1">
                <button id="setScaleButton">D√©finir l'√©chelle</button>
                <div id="scale-info">√âchelle non d√©finie.</div>
            </div>
        </details>
        
        <details open>
            <summary>2. Mode de travail</summary>
            <div class="details-content button-group">
                <button id="modePlantsButton" class="active-mode">Plantes</button>
                <button id="modeIrrigationButton">Irrigation</button>
                <button id="modePathsButton">All√©es</button>
                <button id="modeMulchButton">Paillage</button>
            </div>
        </details>

        <div id="plant-controls">
            <details open>
                <summary>3. Types de plantes</summary>
                <div class="details-content">
                    <label for="plantName">Nom :</label>
                    <input type="text" id="plantName" placeholder="Ex: Tomate cerise">
                    <div class="input-group">
                        <div style="flex-grow:1;">
                            <label for="plantSpacing">Espacement (cm) :</label>
                            <input type="number" id="plantSpacing" value="50" min="1" style="width: calc(100% - 12px);">
                        </div>
                        <div style="flex-grow:1;">
                            <label for="plantEmoji">Emoji :</label>
                            <input type="text" id="plantEmoji" placeholder="üçÖ" maxlength="2" style="width: calc(100% - 12px);">
                        </div>
                        <div>
                            <label>Couleur</label>
                            <input type="color" id="plantColor" value="#ff0000">
                        </div>
                    </div>
                    <button id="addPlantTypeButton">Ajouter ce type</button>
                    <hr style="margin:15px 0;">
                    <div id="plant-types-list"></div>
                </div>
            </details>
            <details open>
                <summary>4. Action sur les plantes</summary>
                <div class="details-content">
                    <label>Cliquez pour choisir une action :</label>
                    <div class="button-group">
                        <button id="plantModeAdd" class="active-mode button-secondary">Ajouter</button>
                        <button id="plantModeMove" class="button-secondary">D√©placer</button>
                        <button id="plantModeDelete" class="button-secondary">Supprimer</button>
                    </div>
                </div>
            </details>
            <details>
                <summary>5. Placement en grille</summary>
                <div class="details-content">
                    <div class="input-group">
                        <div>
                            <label for="gridRows">Lignes :</label>
                            <input type="number" id="gridRows" value="3" min="1">
                        </div>
                        <div>
                            <label for="gridCols">Colonnes :</label>
                            <input type="number" id="gridCols" value="5" min="1">
                        </div>
                    </div>
                    <button id="gridPlacementButton">Activer le mode Grille</button>
                </div>
            </details>
        </div>

        <div id="irrigation-controls" style="display:none;">
             <details open>
                <summary>3. Irrigation</summary>
                <div class="details-content">
                    <p style="font-size:0.9em; margin: 0 0 10px 0;">Cliquez pour poser les points. Cliquez sur un point existant pour cr√©er une branche. Clic droit pour annuler le dernier point.</p>
                    <div id="irrigation-info">Longueur totale : 0.00 m</div>
                    <button id="clearPipeButton" class="button-orange">Effacer l'irrigation</button>
                </div>
             </details>
        </div>

        <div id="path-controls" style="display:none;">
            <details open>
                <summary>3. All√©es</summary>
                <div class="details-content">
                    <label for="pathWidth">Largeur de l'all√©e (cm):</label>
                    <input type="number" id="pathWidth" value="30" min="1">
                    <p style="font-size:0.9em; margin: 10px 0 10px 0;">Cliquez pour dessiner les all√©es. Clic droit pour annuler le dernier point.</p>
                    <div id="path-info">Longueur totale : 0.00 m</div>
                    <button id="clearPathsButton" class="button-orange">Effacer les all√©es</button>
                </div>
            </details>
        </div>

        <div id="mulch-controls" style="display:none;">
            <details open>
                <summary>3. Paillage</summary>
                <div class="details-content">
                    <label for="mulchThickness">√âpaisseur du paillage (cm):</label>
                    <input type="number" id="mulchThickness" value="5" min="1">
                    <p style="font-size:0.9em; margin: 10px 0 10px 0;">Cliquez pour dessiner une zone de paillage. Clic droit pour annuler le dernier point.</p>
                    <button id="finishPolygonButton">Terminer la zone</button>
                    <div id="mulch-info" style="margin-top:10px;">Volume requis : 0.00 litres</div>
                    <button id="clearMulchButton" class="button-orange">Effacer le paillage</button>
                </div>
            </details>
        </div>
        
        <div id="global-plant-count" style="font-weight:bold; padding: 10px; border: 1px solid var(--border-color); border-radius: 5px; background-color: #f8f9fa; text-align: center;">
            Nombre total de plantes : 0
        </div>

        <details>
            <summary>Actions</summary>
            <div class="details-content">
                <div class="button-group">
                    <button id="saveButton" class="button-secondary">Sauvegarder</button>
                    <button id="loadButton" class="button-secondary">Charger</button>
                </div>
                <div class="button-group">
                    <button id="exportButton">Exporter PNG</button>
                    <button id="clearButton" class="button-tertiary">Tout effacer</button>
                </div>
            </div>
        </details>
    </div>

    <div id="canvas-container">
        <canvas id="gardenCanvas"></canvas>
    </div>

    <div id="emoji-picker" class="emoji-picker-hidden"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gardenCanvas');
        const ctx = canvas.getContext('2d');
        // ... (toutes les autres r√©f√©rences au DOM)
        const imageLoader = document.getElementById('imageLoader');
        const setScaleButton = document.getElementById('setScaleButton');
        const scaleInfo = document.getElementById('scale-info');
        const refDistanceInput = document.getElementById('refDistance');
        const addPlantTypeButton = document.getElementById('addPlantTypeButton');
        const plantTypesListDiv = document.getElementById('plant-types-list');
        const globalPlantCountDiv = document.getElementById('global-plant-count');
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');
        const exportButton = document.getElementById('exportButton');
        const clearButton = document.getElementById('clearButton');
        const modePlantsButton = document.getElementById('modePlantsButton');
        const modeIrrigationButton = document.getElementById('modeIrrigationButton');
        const plantControls = document.getElementById('plant-controls');
        const irrigationControls = document.getElementById('irrigation-controls');
        const irrigationInfo = document.getElementById('irrigation-info');
        const clearPipeButton = document.getElementById('clearPipeButton');
        const gridPlacementButton = document.getElementById('gridPlacementButton');
        const gridRowsInput = document.getElementById('gridRows');
        const gridColsInput = document.getElementById('gridCols');
        const plantModeAddButton = document.getElementById('plantModeAdd');
        const plantModeMoveButton = document.getElementById('plantModeMove');
        const plantModeDeleteButton = document.getElementById('plantModeDelete');
        const emojiPicker = document.getElementById('emoji-picker');
        const plantEmojiInput = document.getElementById('plantEmoji');
        const modePathsButton = document.getElementById('modePathsButton');
        const pathControls = document.getElementById('path-controls');
        const pathWidthInput = document.getElementById('pathWidth');
        const pathInfo = document.getElementById('path-info');
        const clearPathsButton = document.getElementById('clearPathsButton');
        const modeMulchButton = document.getElementById('modeMulchButton');
        const mulchControls = document.getElementById('mulch-controls');
        const mulchThicknessInput = document.getElementById('mulchThickness');
        const mulchInfo = document.getElementById('mulch-info');
        const finishPolygonButton = document.getElementById('finishPolygonButton');
        const clearMulchButton = document.getElementById('clearMulchButton');

        const GARDEN_EMOJIS = [
            'üçÖ', 'ü•ï', 'ü•¨', 'üçì', 'üåΩ', 'üå∂Ô∏è', 'ü•¶', 'üçá', 'üçâ', 'üåª', 'üå≥', 'ü•î',
            'üçÜ', 'ü•í', 'ü´ë', 'üßÖ', 'üçÑ', 'üåπ', 'üå∑', 'üåø', 'üçé', 'üçê', 'üçä', 'üçã'
        ];

        // --- √âtat de l'application ---
        let plantAction = 'placing'; // 'placing', 'moving', 'deleting'
        let backgroundImage = null;
        let scale = { pixels: 0, meters: 0, pixelsPerMeter: 0 };
        let plantTypes = {};
        let placedPlants = [];
        let irrigationSystem = { pipes: [] };
        let pathSystem = { paths: [] };
        let mulchSystem = { polygons: [], currentPolygon: [] };
        let selectedPlantType = null;
        let mainMode = 'placing'; // 'placing' ou 'irrigation'
        let placementSubMode = 'single'; // 'single' ou 'grid'

        // --- √âtats d'interaction ---
        let isScaling = false, scaleStartPoint = null, scaleCurrentMousePos = null;
        let isDragging = false, draggedPlant = null, dragOffsetX, dragOffsetY;

        // ===================================
        // --- DESSIN & MISES √Ä JOUR ---
        // ===================================

        function createMulchPattern() {
            const patternCanvas = document.createElement('canvas');
            const patternCtx = patternCanvas.getContext('2d');
            const size = 20;
            patternCanvas.width = size;
            patternCanvas.height = size;
            patternCtx.fillStyle = 'rgba(210, 180, 140, 0.5)'; // Beige 50% transparent
            patternCtx.fillRect(0, 0, size, size);
            patternCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            patternCtx.beginPath();
            patternCtx.arc(size / 4, size / 4, 1, 0, 2 * Math.PI);
            patternCtx.arc(size * 3 / 4, size * 3 / 4, 1, 0, 2 * Math.PI);
            patternCtx.fill();
            return ctx.createPattern(patternCanvas, 'repeat');
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (backgroundImage) ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);

            // --- 1. DESSINER LE PAILLAGE (en premier pour √™tre en fond) ---
            const mulchPattern = createMulchPattern();
            ctx.fillStyle = mulchPattern;
            
            // Dessiner les polygones finalis√©s
            mulchSystem.polygons.forEach(polygon => {
                if (polygon.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(polygon[0].x, polygon[0].y);
                    for (let i = 1; i < polygon.length; i++) {
                        ctx.lineTo(polygon[i].x, polygon[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            });

            // Dessiner le polygone en cours de cr√©ation
            if (mulchSystem.currentPolygon.length > 0) {
                ctx.beginPath();
                ctx.moveTo(mulchSystem.currentPolygon[0].x, mulchSystem.currentPolygon[0].y);
                for (let i = 1; i < mulchSystem.currentPolygon.length; i++) {
                    ctx.lineTo(mulchSystem.currentPolygon[i].x, mulchSystem.currentPolygon[i].y);
                }
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // --- 2. DESSINER LES AUTRES √âL√âMENTS ---

            // Dessin de l'irrigation (avec branches)
            irrigationSystem.pipes.forEach(pipe => {
                if (pipe.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(pipe[0].x, pipe[0].y);
                    for (let i = 1; i < pipe.length; i++) ctx.lineTo(pipe[i].x, pipe[i].y);
                    ctx.strokeStyle = '#3498db'; ctx.lineWidth = 4; ctx.stroke();
                }
            });
            irrigationSystem.pipes.forEach(pipe => pipe.forEach(p => { // Dessiner les points par-dessus
                ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI); ctx.fillStyle = '#2980b9'; ctx.fill();
            }));

            // Dessin des all√©es
            const pathWidthPx = scale.pixelsPerMeter > 0 ? (parseInt(pathWidthInput.value, 10) / 100) * scale.pixelsPerMeter : 0;
            if (pathWidthPx > 0) {
                pathSystem.paths.forEach(path => {
                    if (path.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(path[0].x, path[0].y);
                        for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                        ctx.strokeStyle = '#8B4513'; // Marron selle
                        ctx.lineWidth = pathWidthPx;
                        ctx.lineCap = 'round';
                        ctx.stroke();
                    }
                });
            }
            pathSystem.paths.forEach(path => path.forEach(p => { // Dessiner les points par-dessus
                ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI); ctx.fillStyle = '#654321'; ctx.fill();
            }));

            // Dessin des plantes (avec emojis)
            placedPlants.forEach(plant => {
                ctx.beginPath(); ctx.arc(plant.x, plant.y, plant.radiusPx, 0, 2 * Math.PI);
                ctx.fillStyle = plant.color + '80'; ctx.fill();
                ctx.strokeStyle = plant.color; ctx.lineWidth = 2; ctx.stroke();
                if (plant.emoji) {
                    const fontSize = plant.radiusPx * 1.5;
                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(plant.emoji, plant.x, plant.y);
                }
            });

            // Dessin de la ligne de mesure pendant la mise √† l'√©chelle
            if (isScaling && scaleStartPoint && scaleCurrentMousePos) {
                ctx.beginPath();
                ctx.moveTo(scaleStartPoint.x, scaleStartPoint.y);
                ctx.lineTo(scaleCurrentMousePos.x, scaleCurrentMousePos.y);
                ctx.strokeStyle = '#f57c00'; // Orange vif
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]); // R√©initialiser pour les autres traits
            }
        }
        
        // ... (autres fonctions de mise √† jour UI) ...
        function updateAllUI() {
            updatePlantTypesUI();
            updateGlobalPlantCount();
            updatePipeLength();
            updatePathLength();
            updateMulchVolume();
            updateModeUI();
            updateScaleInfo();
        }
        
        function updatePlantTypesUI() {
            plantTypesListDiv.innerHTML = '';
            const counts = {};
            placedPlants.forEach(p => { counts[p.typeName] = (counts[p.typeName] || 0) + 1; });
            for (const name in plantTypes) {
                const type = plantTypes[name];
                const div = document.createElement('div');
                div.innerHTML = `<span>${type.emoji || ''} ${name} (${type.spacingCm} cm)</span><span class="plant-count">${counts[name] || 0}</span>`;
                div.style.borderLeft = `5px solid ${type.color}`;
                if (name === selectedPlantType) div.classList.add('selected');
                div.onclick = () => {
                    selectedPlantType = name;
                    setMainMode('placing');
                    updatePlantTypesUI();
                };
                plantTypesListDiv.appendChild(div);
            }
        }
        
        function updatePipeLength() {
            let totalPixelLength = 0;
            irrigationSystem.pipes.forEach(pipe => {
                for (let i = 1; i < pipe.length; i++) {
                    totalPixelLength += Math.hypot(pipe[i].x - pipe[i-1].x, pipe[i].y - pipe[i-1].y);
                }
            });
            const totalMeterLength = scale.pixelsPerMeter > 0 ? totalPixelLength / scale.pixelsPerMeter : 0;
            irrigationInfo.textContent = `Longueur totale : ${totalMeterLength.toFixed(2)} m`;
        }

        function updatePathLength() {
            let totalPixelLength = 0;
            pathSystem.paths.forEach(path => {
                for (let i = 1; i < path.length; i++) {
                    totalPixelLength += Math.hypot(path[i].x - path[i-1].x, path[i].y - path[i-1].y);
                }
            });
            const totalMeterLength = scale.pixelsPerMeter > 0 ? totalPixelLength / scale.pixelsPerMeter : 0;
            pathInfo.textContent = `Longueur totale : ${totalMeterLength.toFixed(2)} m`;
        }

        function calculatePolygonArea(vertices) {
            let area = 0;
            for (let i = 0; i < vertices.length; i++) {
                const j = (i + 1) % vertices.length;
                area += vertices[i].x * vertices[j].y;
                area -= vertices[j].x * vertices[i].y;
            }
            return Math.abs(area / 2);
        }

        function updateMulchVolume() {
            if (scale.pixelsPerMeter <= 0) {
                mulchInfo.textContent = 'Volume requis : 0.00 litres (√©chelle non d√©finie)';
                return;
            }
            let totalPixelArea = 0;
            mulchSystem.polygons.forEach(polygon => {
                totalPixelArea += calculatePolygonArea(polygon);
            });

            const totalSquareMeters = totalPixelArea / (scale.pixelsPerMeter * scale.pixelsPerMeter);
            const thicknessMeters = parseInt(mulchThicknessInput.value, 10) / 100;
            const volumeM3 = totalSquareMeters * thicknessMeters;
            const volumeLiters = volumeM3 * 1000;

            mulchInfo.textContent = `Volume requis : ${volumeLiters.toFixed(2)} litres`;
        }

        function updateGlobalPlantCount() {
             globalPlantCountDiv.textContent = `Nombre total de plantes : ${placedPlants.length}`;
        }

        function updateScaleInfo() {
            if (scale.pixelsPerMeter > 0) {
                scaleInfo.textContent = `√âchelle : 1m = ${scale.pixelsPerMeter.toFixed(2)} pixels.`;
                scaleInfo.style.backgroundColor = '#e9f5e9';
            } else {
                scaleInfo.textContent = '√âchelle non d√©finie.';
                scaleInfo.style.backgroundColor = '#e9f5e9';
            }
        }

        // ===================================
        // --- GESTION DES MODES & √âV√âNEMENTS ---
        // ===================================
        
        function setMainMode(mode) {
            mainMode = mode;
            // Si on quitte le mode plante, on d√©sactive le mode grille
            if (mode !== 'placing') {
                placementSubMode = 'single';
                gridPlacementButton.classList.remove('grid-active');
                gridPlacementButton.textContent = 'Activer le mode Grille';
            }
            updateModeUI();
        }
        
        function updateModeUI() {
            plantControls.style.display = mainMode === 'placing' ? 'block' : 'none';
            irrigationControls.style.display = mainMode === 'irrigation' ? 'block' : 'none';
            pathControls.style.display = mainMode === 'paths' ? 'block' : 'none';
            mulchControls.style.display = mainMode === 'mulching' ? 'block' : 'none';

            modePlantsButton.classList.toggle('active-mode', mainMode === 'placing');
            modeIrrigationButton.classList.toggle('active-mode', mainMode === 'irrigation');
            modePathsButton.classList.toggle('active-mode', mainMode === 'paths');
            modeMulchButton.classList.toggle('active-mode', mainMode === 'mulching');
            updateCanvasCursor();
        }
        
        function updateCanvasCursor() {
            canvas.classList.remove('mode-placing', 'mode-irrigation', 'grid-placement-mode', 'mode-moving', 'mode-deleting', 'mode-paths', 'mode-mulching');
            if (mainMode === 'placing') {
                if (placementSubMode === 'grid') {
                    canvas.classList.add('grid-placement-mode');
                } else {
                    // Le curseur d√©pend de l'action sur les plantes
                    if (plantAction === 'placing') canvas.classList.add('mode-placing');
                    else if (plantAction === 'moving') canvas.classList.add('mode-moving');
                    else if (plantAction === 'deleting') canvas.classList.add('mode-deleting');
                }
            } else if (mainMode === 'irrigation') {
                canvas.classList.add('mode-irrigation');
            } else if (mainMode === 'paths') {
                canvas.classList.add('mode-paths');
            } else if (mainMode === 'mulching') {
                canvas.classList.add('mode-mulching');
            }
        }
        
        imageLoader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                backgroundImage = new Image();
                backgroundImage.onload = () => {
                    canvas.width = backgroundImage.width;
                    canvas.height = backgroundImage.height;
                    draw();
                };
                backgroundImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        addPlantTypeButton.addEventListener('click', () => {
            const name = document.getElementById('plantName').value;
            const spacing = parseInt(document.getElementById('plantSpacing').value, 10);
            const color = document.getElementById('plantColor').value;
            const emoji = document.getElementById('plantEmoji').value;
            if (!name || !spacing) return alert("Nom et espacement requis.");
            plantTypes[name] = { spacingCm: spacing, color: color, emoji: emoji };
            document.getElementById('plantName').value = '';
            document.getElementById('plantEmoji').value = '';
            updatePlantTypesUI();
        });

        gridPlacementButton.addEventListener('click', () => {
            if (placementSubMode === 'single') {
                placementSubMode = 'grid';
                gridPlacementButton.classList.add('grid-active');
                gridPlacementButton.textContent = 'Mode Grille ACTIF (cliquez sur le plan)';
            } else {
                placementSubMode = 'single';
                gridPlacementButton.classList.remove('grid-active');
                gridPlacementButton.textContent = 'Activer le mode Grille';
            }
            updateCanvasCursor();
        });

        function setPlantAction(mode) {
            plantAction = mode;
            plantModeAddButton.classList.toggle('active-mode', mode === 'placing');
            plantModeMoveButton.classList.toggle('active-mode', mode === 'moving');
            plantModeDeleteButton.classList.toggle('active-mode', mode === 'deleting');
            updateCanvasCursor();
        }

        plantModeAddButton.addEventListener('click', () => setPlantAction('placing'));
        plantModeMoveButton.addEventListener('click', () => setPlantAction('moving'));
        plantModeDeleteButton.addEventListener('click', () => setPlantAction('deleting'));

        modePlantsButton.addEventListener('click', () => setMainMode('placing'));
        modeIrrigationButton.addEventListener('click', () => setMainMode('irrigation'));
        modePathsButton.addEventListener('click', () => setMainMode('paths'));
        modeMulchButton.addEventListener('click', () => setMainMode('mulching'));

        // --- Logique du s√©lecteur d'emojis ---
        function populateEmojiPicker() {
            emojiPicker.innerHTML = '';
            GARDEN_EMOJIS.forEach(emoji => {
                const button = document.createElement('button');
                button.textContent = emoji;
                button.onclick = () => {
                    plantEmojiInput.value = emoji;
                    emojiPicker.classList.add('emoji-picker-hidden');
                };
                emojiPicker.appendChild(button);
            });
        }

        plantEmojiInput.addEventListener('click', (e) => {
            e.stopPropagation();
            const rect = plantEmojiInput.getBoundingClientRect();
            emojiPicker.style.top = `${rect.bottom + window.scrollY}px`;
            emojiPicker.style.left = `${rect.left + window.scrollX}px`;
            emojiPicker.classList.toggle('emoji-picker-hidden');
        });

        document.addEventListener('click', (e) => {
            if (!emojiPicker.contains(e.target) && e.target !== plantEmojiInput) {
                emojiPicker.classList.add('emoji-picker-hidden');
            }
        });

        // --- GESTION DE LA SOURIS ---
        canvas.addEventListener('click', (e) => {
            if (isDragging || isScaling) return;
            const pos = getMousePos(canvas, e);

            if (mainMode === 'placing') {
                // Logique d√©pend de l'action s√©lectionn√©e
                if (plantAction === 'placing') {
                    if (!selectedPlantType) return alert("S√©lectionnez un type de plante.");
                    if (scale.pixelsPerMeter <= 0) return alert("D√©finissez l'√©chelle d'abord.");

                    if (placementSubMode === 'single') {
                        placeSinglePlant(pos);
                    } else {
                        placeGrid(pos);
                        placementSubMode = 'single'; // Repasser en mode single apr√®s placement
                        gridPlacementButton.classList.remove('grid-active');
                        gridPlacementButton.textContent = 'Activer le mode Grille';
                        updateCanvasCursor();
                    }
                } else if (plantAction === 'deleting') {
                    const clicked = findClickedPlant(pos);
                    if (clicked) {
                        placedPlants.splice(clicked.index, 1);
                    }
                }
                // En mode 'moving', le click ne fait rien, c'est le drag qui compte

            } else if (mainMode === 'irrigation') {
                const existingPoint = findClosestPipeVertex(pos, 10);
                if (existingPoint) {
                    irrigationSystem.pipes.push([existingPoint]);
                } else {
                    if (irrigationSystem.pipes.length === 0) irrigationSystem.pipes.push([]);
                    irrigationSystem.pipes[irrigationSystem.pipes.length - 1].push(pos);
                }
            } else if (mainMode === 'paths') {
                // La logique est similaire √† l'irrigation, mais pour les all√©es
                const existingPathPoint = findClosestPathVertex(pos, 10);
                if (existingPathPoint) {
                    pathSystem.paths.push([existingPathPoint]); // Nouvelle branche d'all√©e
                } else {
                    if (pathSystem.paths.length === 0) {
                        pathSystem.paths.push([]); // Premi√®re all√©e
                    }
                    pathSystem.paths[pathSystem.paths.length - 1].push(pos);
                }
            } else if (mainMode === 'mulching') {
                mulchSystem.currentPolygon.push(pos);
            }

            draw();
            updateAllUI();
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (mainMode === 'placing') {
                const pos = getMousePos(canvas, e);
                const clicked = findClickedPlant(pos);
                if (clicked) {
                    placedPlants.splice(clicked.index, 1);
                }
            }
            else if (mainMode === 'irrigation' && irrigationSystem.pipes.length > 0) {
                let lastPipe = irrigationSystem.pipes[irrigationSystem.pipes.length - 1];
                if(lastPipe.length > 0) lastPipe.pop();
                if(lastPipe.length <= 1) { // Si la branche n'a plus qu'un point (ou 0), on la supprime
                    irrigationSystem.pipes.pop();
                }
            }
            else if (mainMode === 'paths' && pathSystem.paths.length > 0) {
                let lastPath = pathSystem.paths[pathSystem.paths.length - 1];
                if(lastPath.length > 0) lastPath.pop();
                if(lastPath.length <= 1) { // Si la branche n'a plus qu'un point (ou 0), on la supprime
                    pathSystem.paths.pop();
                }
            } else if (mainMode === 'mulching' && mulchSystem.currentPolygon.length > 0) {
                mulchSystem.currentPolygon.pop();
            }
            draw();
            updateAllUI();
        });

        function placeSinglePlant(pos) {
            const type = plantTypes[selectedPlantType];
            const radiusPx = ((type.spacingCm / 2) / 100) * scale.pixelsPerMeter;
            placedPlants.push({ ...pos, radiusPx, typeName: selectedPlantType, color: type.color, emoji: type.emoji });
        }
        
        function placeGrid(startPos) {
            const rows = parseInt(gridRowsInput.value, 10);
            const cols = parseInt(gridColsInput.value, 10);
            const type = plantTypes[selectedPlantType];
            const spacingPx = (type.spacingCm / 100) * scale.pixelsPerMeter;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const pos = {
                        x: startPos.x + c * spacingPx,
                        y: startPos.y + r * spacingPx
                    };
                    placeSinglePlant(pos);
                }
            }
        }
        
        function findClosestPipeVertex(pos, maxDist) {
            for (const pipe of irrigationSystem.pipes) {
                for (const point of pipe) {
                    if (Math.hypot(pos.x - point.x, pos.y - point.y) < maxDist) {
                        return point;
                    }
                }
            }
            return null;
        }

        function findClosestPathVertex(pos, maxDist) {
            for (const path of pathSystem.paths) {
                for (const point of path) {
                    if (Math.hypot(pos.x - point.x, pos.y - point.y) < maxDist) {
                        return point;
                    }
                }
            }
            return null;
        }
        
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }

        function findClickedPlant(pos) {
            // It√©rer en sens inverse pour que les plantes au-dessus soient prioritaires
            for (let i = placedPlants.length - 1; i >= 0; i--) {
                const plant = placedPlants[i];
                const distance = Math.hypot(pos.x - plant.x, pos.y - plant.y);
                if (distance < plant.radiusPx) {
                    return { plant, index: i };
                }
            }
            return null;
        }

        // --- SAUVEGARDE ET CHARGEMENT ---
        saveButton.addEventListener('click', () => {
            const dataToSave = {
                scale, plantTypes, placedPlants, irrigationSystem, pathSystem, mulchSystem
            };
            localStorage.setItem('gardenPlanAdvanced', JSON.stringify(dataToSave));
            alert('Plan sauvegard√© !');
        });

        loadButton.addEventListener('click', () => {
            const savedData = localStorage.getItem('gardenPlanAdvanced');
            if (savedData) {
                const data = JSON.parse(savedData);
                scale = data.scale;
                plantTypes = data.plantTypes;
                placedPlants = data.placedPlants;
                irrigationSystem = data.irrigationSystem || { pipes: [] }; // compatibilit√©
                pathSystem = data.pathSystem || { paths: [] }; // compatibilit√©
                mulchSystem = data.mulchSystem || { polygons: [], currentPolygon: [] }; // compatibilit√©
                draw();
                updateAllUI();
                alert("Plan charg√©.");
            } else {
                alert('Aucun plan sauvegard√© trouv√©.');
            }
        });

        // Initialisation de la page
        updateAllUI();
        populateEmojiPicker();
        
        // ... (autres √©couteurs d'√©v√©nements comme setScale, clear, drag&drop, etc. sont similaires aux versions pr√©c√©dentes et omis pour la bri√®vet√© de l'explication mais pr√©sents dans le code)
        // Le code complet pour les autres boutons est ici pour la fonctionnalit√©
        setScaleButton.addEventListener('click', () => {
            if (!backgroundImage) {
                alert("Veuillez d'abord charger une image de fond.");
                return;
            }
            isScaling = true;
            canvas.classList.add('scaling-mode');
            scaleInfo.textContent = `MODE √âCHELLE : Tracez une ligne sur l'image correspondant √† ${refDistanceInput.value}m.`;
            scaleInfo.style.backgroundColor = '#ffecb3';
            setScaleButton.classList.add('active-mode');
        });
        clearPipeButton.addEventListener('click', () => { irrigationSystem.pipes = []; draw(); updatePipeLength(); });
        clearPathsButton.addEventListener('click', () => { pathSystem.paths = []; draw(); updateAllUI(); });
        clearMulchButton.addEventListener('click', () => { mulchSystem.polygons = []; mulchSystem.currentPolygon = []; draw(); updateAllUI(); });

        finishPolygonButton.addEventListener('click', () => {
            if (mulchSystem.currentPolygon.length > 2) {
                mulchSystem.polygons.push([...mulchSystem.currentPolygon]);
                mulchSystem.currentPolygon = [];
                draw();
                updateAllUI();
            } else {
                alert("Une zone de paillage doit avoir au moins 3 points.");
            }
        });

        clearButton.addEventListener('click', () => { if(confirm('Tout effacer ?')){ placedPlants = []; irrigationSystem = {pipes:[]}; pathSystem = {paths:[]}; mulchSystem = {polygons:[], currentPolygon:[]}; draw(); updateAllUI(); } });
        exportButton.addEventListener('click', () => { const link = document.createElement('a'); link.download = 'plan_jardin.png'; link.href = canvas.toDataURL(); link.click(); });
        // Drag & drop etc.
        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Seul le clic principal
            const pos = getMousePos(canvas, e);

            if (isScaling) {
                scaleStartPoint = pos;
                return;
            }

            if (mainMode === 'placing' && plantAction === 'moving') {
                const clicked = findClickedPlant(pos);
                if (clicked) {
                    isDragging = true;
                    draggedPlant = clicked.plant;
                    dragOffsetX = pos.x - draggedPlant.x;
                    dragOffsetY = pos.y - draggedPlant.y;
                    canvas.classList.add('dragging-mode');
                }
            }
        });
        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(canvas, e);
            // Mise √† jour de la ligne de mesure en temps r√©el
            if (isScaling && scaleStartPoint) {
                scaleCurrentMousePos = pos;
                draw();
            }
            // Mettre √† jour la position de la plante d√©plac√©e
            if (isDragging && draggedPlant) {
                draggedPlant.x = pos.x - dragOffsetX;
                draggedPlant.y = pos.y - dragOffsetY;
                draw();
            }
        });
        canvas.addEventListener('mouseup', (e) => {
            if (e.button !== 0) return; // Only main button

            // --- Fin de la mise √† l'√©chelle ---
            if (isScaling && scaleStartPoint) {
                const endPos = getMousePos(canvas, e);
                const pixelDist = Math.hypot(endPos.x - scaleStartPoint.x, endPos.y - scaleStartPoint.y);
                const realDist = parseFloat(refDistanceInput.value);

                if (pixelDist > 5 && realDist > 0) {
                    scale = {
                        pixels: pixelDist,
                        meters: realDist,
                        pixelsPerMeter: pixelDist / realDist
                    };
                }

                isScaling = false;
                scaleStartPoint = null;
                scaleCurrentMousePos = null; // Nettoyer la position
                canvas.classList.remove('scaling-mode');
                setScaleButton.classList.remove('active-mode');
                updateAllUI(); // Met √† jour l'info de l'√©chelle et autres
                draw();
            }

            // --- Fin du Drag & Drop ---
            if (isDragging) {
                isDragging = false;
                draggedPlant = null;
                canvas.classList.remove('dragging-mode');
            }
        });

    });
    </script>
</body>
</html>
